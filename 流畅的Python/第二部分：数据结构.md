# 数据结构

## 序列构成的数组

### 内置序列类型

- 按存放类型

	- 容器序列

		- 特点：可以存放不同的数据
		- 存放的是任意类型对象的引用
		- 具体类型

			- list
			- collections.deque
			- tuple

	- 扁平序列

		- 特点：只能容纳一种类型
		- 存放的是值而不是引用，扁平序列是一段连续的内存空间
		- 具体类型

			- bytes
			- str
			- bytearray
			- memoryview
			- array.array

- 是否可被修改

	- 可变序列

		- MutableSequence 抽象基类
		- 具体类型

			- bytearray
			- list
			- array,array
			- collections.deque
			- memoryview

	- 不可变序列

		- Sequence 抽象基类
		- 具体类型

			- str
			- tuple
			- bytes

### 列表推导（list comprehension）和生成器表达式（generator expression）

简称： listcomps & genexps

- 列表推导

	- 作用只有一个：生成列表
	- 列表推导和可读性

		- 如果列表推导超过两行，可能需要考虑用 for 循环重写
		- 列表推导在 Python3 不会有变量泄露的问题，因为 Python3 有了自己的局部作用域，表达式内部的变量只在局部起作用

	- 列表推导同 filter 和 map 的比较

		- 第五章会做详细的介绍

	- 笛卡尔积：多 for 循环

- 生成器表达式

	- 生成器表达式背后遵守了迭代器协议，可以逐个的产生元素，而不是建立一个完整的列表然后再把这个列表传递到某个构造函数里（前者更节省内存）
	- 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外在用括号把它围起来
	- 工作原理

		- 第 14 章会做对应的介绍

### 元祖不仅仅是不可变列表

- 元祖和记录

	- 元祖其实对数据的记录：元祖中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义
	- 举例：``` city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66. 8014) ```

- 元祖和拆包

	- for 循环/赋值/%运算符/*运算符 可以分别提取元祖里的元素（包括平行赋值也是元祖拆包）

		- 举例：``` for city, year in [('tokyo', 2003), ('beijing', 2008)]: .... ```

	- 元祖拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这个元素的空档数一致（可以用占位符 _, 也可以用 * 处理剩下的元素）

		- ```a, _ = (2, 3)```
		- ``` a, b, *rest = range(5) ```
		- ``` *head, a, b = range(5) ```
		- ``` a, *body, b = range(5) ```

- 嵌套元祖拆包

	- 接受表达式的元祖可以是嵌套式的，例如（a, b, (c, d)）只要接受元祖的嵌套结构符合表达式本身的嵌套结构， Python 就可以作出正确的回应

- 具名元祖 （collections.namedtuple）

	- 工厂函数，可以用于构建一个带字段的元祖和一个有名字的类

		- namedtuple 构建的类的实例消耗的内存和元祖是一样的，因为字段名都被存在对应的类里面。但这个实例很普通的对象实例比起来更小一些，因为 Python 不会用 __dict__ 来存放这些实例属性

	- 创建方式

		- ``` City = namedtuple('City', ['name', 'coutry']) ```

		  两个参数：类名和属性列表 属性列表可以是数个字段串组成的可迭代对象，也可以是由空格分隔开的字段名组成的字符串

	- 有普通元祖的所有属性，还有一些自己的专有属性

		- ``` _fields ``` 类属性: 包含这个类所有字段名称的元祖
		- 类方法 ```_make(iterable) ```： 通过接受一个可迭代对象来生成这个类的一个实例
		- 示例方法 ``` _asdict() ``` ：把具名元祖以 collections.OrderedDict 的形式返回

- 作为不可变列表的元祖

	- 除了跟增减元素相关的方法外，元祖支持列表其他所有方法，元祖也没有  ``` __reversed__ ```方法 但这个方法只是个优化 ```reversed(my_tuple)``` 这个用法在没有  ``` __reversed__ ```方法情况下也是合法的

### 切片

- 为什么切片和区间会忽略左后一个元素？（左闭右开的好处）

	- 当只有最后一个位置信息时，也可以快速看出切片和区间里有几个元素
	- 当起止位置信息都可见时，可以快速计算出切片和区间长度

- 对对象进行切片

	- seq[start:stop:step] 进行求值时，Python 会调用 ```seq.__getitem__(slice(start, stop, step))```

- 多维切片和省略

	- [] 运算符里还可以使用逗号分开的多个索引或者是切片。实现多维切片对象的特使方法```__getitem__``` 和 ```__setitem__``` 需要以元祖的形式来接收a[i, j] 中的索引
	- 省略（ellipsis) 正确写法是三个英文句号, 实际上它是 Ellipsis 对象的别名， Ellipsis 对象是 ellipsis 类的单一实例

- 给切片赋值

	- ```li[2:5] = [20, 30]```
	- ```del li[2:5] ```
	- ```li[2:5] = 100``` 会报错，右侧必须是可迭代对象

### 对序列使用+和*

- + 和 * 都不修改原有操作对象，而是构建一个全新序列
- 在 ``` a * n ``` 这个语句中，序列 a 的元素是对其他可变对象的引用的话，这些引用复制后指向同一个对象
- 建立由列表组成的列表

### 序列的增量赋值

- ```+=```

	- 特殊方法：```__iadd__``` 如果没有实现，Python 会退一步调用 ```__add__```

- ```*=```

	- 特殊方法：```__imul__```

- 对元祖中的 list 元素使用 +=

	- 不要把可变对象放在元祖里
	- 增量赋值不是原子操作
	- ```dis.dis('s[a]+=b') ```

### list.sort 方法和内置函数 sorted

- 区别

	- sorted 会新建一个列表作为返回值
	- list.sort 会就地排序列表，不会把原列表复制一份

- 关键参数

	- reverse 是否降序
	- key 排序方式

### 用 bisect 来管理已排序的列表（二分查找算法）

- 用 bisect 来搜索 ```bisect(haystack, needle)``` 在 haystack 里面搜索 needle 的位置，该位置满足的条件是，把 needle 插入这个位置后， haystack 还能保持升序

## 字典和集合

## 文本和字节序列
